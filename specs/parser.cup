package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaración del código de usuario

action code {:
	
	// Codigo del equipo docente
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory();

	//Lista para almacenar las cuadruplas de cadenas de caracteres
	List<QuadrupleIF> listaCadenas = new ArrayList<QuadrupleIF>();

	// Metodos creados por mi
	// Metodo para comprobar si existe un simbolo 
	public void errorSiExisteSimbolo(String id, int linea){ 
		// Recuperamos el ambito y obtenemos la tabla de simbolos
		ScopeIF scope = scopeManager.getCurrentScope();
		SymbolTableIF tablaSimbolos = scope.getSymbolTable();

		// Comprobamos si la tabla de simbolos contiene el simbolo
		if(tablaSimbolos.containsSymbol(id)){
			semanticErrorManager.semanticFatalError("Simbolo " + id + " en la linea " + linea + " declarado anteriormente, error.");
		}
	}

	// Metodo para comprobar si existe un tipo
	public void errorSiExisteTipo(String id, int linea){ 
		if(scopeManager.containsType(id)){
			semanticErrorManager.semanticFatalError("Identificador " + id + " en la linea " + linea + " declarado anteriormente, error.");
		}
	}
	
:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaración de terminales

terminal Token RANGO;
terminal Token ASIGNACIONVECTOR;
terminal Token STARTIF;
terminal Token NOLOGICO;
terminal Token FRETURN;
terminal Token COMIENZOPROGRAMA;
terminal Token ENTERO;
terminal Token FINBLOQUESENTENCIAS;
terminal Token COMIENZOPROCEDIMIENTO;
terminal Token COMIENZOBUCLEPARA;
terminal Token BOOLEANO;
terminal Token COMIENZOSI;
terminal Token DECLVECTOR;
terminal Token CIZQUIERDO;
terminal Token DECLAREFUNCION;
terminal Token CDERECHO;
terminal Token IDEN;
terminal Token IGUALDAD;
terminal Token ALTERNATIVASI;
terminal Token DECLVARIABLES;
terminal Token STRING;
terminal Token FALSO;
terminal Token PARAMETROVALOR;
terminal Token PIZQUIERDO;
terminal Token PDERECHO;
terminal Token CIERTO;
terminal Token RANGOBUCLEPARA;
terminal Token PRODUCTO;
terminal Token SUMA;
terminal Token COMIENZOSUBPROGRAMAS;
terminal Token COMIENZODECLTIPOS;
terminal Token DIDENTIFICADORES;
terminal Token FINPROGRAMA;
terminal Token BCONSTANTES;
terminal Token ESCRIBIR;
terminal Token NUM;
terminal Token COMIENZO;
terminal Token YLOGICA;
terminal Token DELIMFUNC;
terminal Token DSENTENCIAS;
terminal Token MENORQUE;
terminal Token ASIGNACION;




// Declaración de no terminales


non terminal  			program;
non terminal Axiom		axiom;
non terminal  			epsilon;
non terminal defconstantes;
non terminal Valorconstante valorconstante;
non terminal seccionconstantes;
non terminal deftipos;
non terminal Tipovector tipovector;
non terminal Valorango valorango;
non terminal secciontipos;
non terminal Defvariables defvariables;
non terminal Tipovariable tipovariable;
non terminal Listavariables listavariables;
non terminal seccionvariables;
non terminal defsubprograma;
non terminal puntoycomaopcional;

non terminal Tipovector tiporetornofuncion;
non terminal seccionsubprograma;
non terminal Sentencia defprincipal;
non terminal Selectorvalororeferencia selectorvalororeferencia;


non terminal Expresion expresion;
non terminal Expresion expresionlvl2;
non terminal Expresion expresionlvl3;
non terminal Expresion expresionlvl4;
non terminal Expresion expresionlvl5;




non terminal Miembrovector miembrovector;
non terminal procedimiento;
non terminal funcion;
non terminal selectorpof;

non terminal Listavariables parametrofuncionoproc;
non terminal Llamadafuncion llamadafuncion ; 

non terminal Parteizquierdaasignacion parteizquierdaasignacion;  
non terminal Sentencia sentenciadeasignacion;

non terminal ParametroEscribir parametroEscribir ;
non terminal Sentencia sentenciaEscribir ;

non terminal Sentencia sentencia;
non terminal Sentencia sentenciaFuncion;
non terminal Sentencia listaSentencias;
non terminal ListaSentenciasFuncion listaSentenciasFuncion;
non terminal sentenciaif;
non terminal Sentencia sentenciaifFuncion;
non terminal rellenoif;
non terminal ListaSentenciasFuncion rellenoifFuncion;
non terminal sentenciafor;
non terminal Sentencia sentenciaforFuncion;
non terminal SentenciaDevolver sentenciaDevolver;


non terminal Expresion parametroasignacion;

non terminal sentenciallamadafuncion;





// Declaración de relaciones de precedencia
precedence left		PIZQUIERDO, PDERECHO, YLOGICA, MENORQUE, IGUALDAD, CIZQUIERDO, CDERECHO, SUMA ;
precedence left PRODUCTO;
precedence right	NOLOGICO;



// Declaración de reglas de producción

start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {: 

		try{
			System.out.println("Codigo intermedio Axioma: " + ax.getIntermediateCode());
		}catch(Exception e){
			System.out.println("Codigo intermedio Axioma: NULL POINTER EXCEPTION");
		}


  		// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		List intermediateCode = ax.getIntermediateCode();
		finalCodeFactory.setEnvironment(CompilerContext.getExecutionEnvironment());
  		finalCodeFactory.create (intermediateCode);

  		// En caso de no comentarse las dos sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest si el compilador no está completo. Esto es debido a que 
  		// aún no se tendrá implementada la generación de código intermedio ni final.
  		// Para la entrega final deberán descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};

axiom ::= defprincipal:def {:
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());	
	AxiomaProp a = new AxiomaProp();
	cb.addQuadruples(def.getIntermediateCode());
	//Aniadimos las cuadruplas de la lista
	if(scopeManager.getCurrentScope().getLevel() == 0){
		for(int i = 0; i < listaCadenas.size(); i++){
			cb.addQuadruple(listaCadenas.get(i));
		}
	}
	
	a.setIntermediateCode(cb.create());

	// Cerramos el ambito actual (current scope)
	scopeManager.closeScope();
	semanticErrorManager.semanticDebug("Se ha cerrado el ambito actual.");

	RESULT = a;
:};

epsilon ::=;

/*================================================*
 *================CONSTANTES======================*
 *================================================*/

//Definición de constantes
defconstantes ::=   IDEN:id ASIGNACION valorconstante:valor DSENTENCIAS {:
	// Recuperamos el ambito y obtenemos la tabla de simbolos
	ScopeIF scope = scopeManager.getCurrentScope();
	SymbolTableIF tablaSimbolos = scope.getSymbolTable();

	// Comprobamos si la tabla de simbolos contiene el simbolo
	if(tablaSimbolos.containsSymbol(id.getLexema().toUpperCase())){
		semanticErrorManager.semanticFatalError("Constante " + id.getLexema().toUpperCase() + " en linea " + id.getLine() + " declarada anteriormente, error.");
	}
	// Comprobamos si la tabla de tipos contiene el identificador.
	errorSiExisteTipo(id.getLexema().toUpperCase(), id.getLine());

	semanticErrorManager.semanticDebug("Constante " + id.getLexema().toUpperCase() + " en linea " + id.getLine() + " no declarada.");

	// Introducimos la constante en la tabla de simbolos
	if(valor.esNumero()){ // si es numero lo aniadimos como numero
		TypeIF t_entero = scopeManager.searchType("ENTERO");
		SymbolConstant simboloConstante = new SymbolConstant(scope, id.getLexema().toUpperCase(), valor.getValor_num(), t_entero);
		tablaSimbolos.addSymbol(simboloConstante);
		semanticErrorManager.semanticDebug("Constante " + id.getLexema().toUpperCase() + " con valor " + valor.getValor_num() + "  declarada.");
	}else{ // si no, es booleano, y lo aniadimos como booleano
		TypeIF t_booleano = scopeManager.searchType("BOOLEANO");
		SymbolConstant simboloConstante = new SymbolConstant(scope, id.getLexema().toUpperCase(), valor.getValor_bool(), t_booleano);
		tablaSimbolos.addSymbol(simboloConstante);
		semanticErrorManager.semanticDebug("Constante " + id.getLexema().toUpperCase() + " con valor " + valor.getValor_bool() + "  declarada.");
	}

:} defconstantes | epsilon; 

valorconstante ::=   FALSO {:
	RESULT = new Valorconstante(false);
:} | CIERTO {:
	RESULT = new Valorconstante(true);
:} | NUM:valor_num {:
	RESULT = new Valorconstante(Integer.parseInt(valor_num.getLexema().toUpperCase()));
:} ;

seccionconstantes ::= BCONSTANTES defconstantes | epsilon;


/*================================================*
 *==========DEFINICION DE TIPOS===================*
 *================================================*/

 //Definición de tipos
deftipos ::=IDEN:id ASIGNACION DECLVECTOR CIZQUIERDO valorango:rangoInferior RANGO valorango:rangoSuperior CDERECHO ASIGNACIONVECTOR tipovector:tipov  DSENTENCIAS {:
	// Recuperamos el ambito y obtenemos la tabla de tipos
	ScopeIF scope = scopeManager.getCurrentScope();
	TypeTableIF tablaTipos = scope.getTypeTable();

	// Emitimos error si el tipo estaba declarado anteriormente.
	if(scopeManager.containsType(id.getLexema().toUpperCase())){ 
		semanticErrorManager.semanticFatalError("Tipo " + id.getLexema().toUpperCase() + " en linea " + id.getLine() + " incluido en la tabla de tipos anteriormente, error.");
	}
	
	// Emitimos error si el identificador está incluido en la tabla de simbolos anteriormente.
	if(scopeManager.containsSymbol(id.getLexema().toUpperCase())){
		semanticErrorManager.semanticFatalError("Simbolo " + id.getLexema().toUpperCase() + " en linea " + id.getLine() + " incluido en la tabla de simbolos anteriormente, error.");
	}
	
	
	// Comprobamos que tanto el rango inferior como el rango superior sean constantes y obtenemos sus valores.

	// Para ello, primero declaramos dos enteros auxiliares
	int numInferior = 0;
	int numSuperior = 0;

	// Comprobación para el rango inferior
	if(rangoInferior.isNum()){ // Si es un numero constante, cogemos directamente su valor
		numInferior = rangoInferior.getNum();
	}else if (rangoInferior.isIden()){ // Si es un identificador
		SymbolIF symbol = scopeManager.searchSymbol(rangoInferior.getId()); // Obtenemos el simbolo
		if(symbol instanceof SymbolConstant){ //El simbolo tiene que ser constante
			numInferior = ((SymbolConstant)symbol).getNum_value(); // Desde la propia tabla de simbolos obtenemos el valor numerico de este simbolo
		}else {
			semanticErrorManager.semanticFatalError("El simbolo "+rangoInferior.getId()+" no corresponde a una constante."); 
		}
	}else if (rangoInferior.isMiembrovector()){ // Si es un miembro de vector, no puede ser utilizado en la definicion de tipos
		semanticErrorManager.semanticFatalError("El simbolo "+rangoInferior.getId()+" no corresponde a una constante de tipo entero."); 
	}

	// Comprobacion para el rango superior
	if(rangoSuperior.isNum()){ // Si es un numero constante, cogemos directamente su valor
		numSuperior = rangoSuperior.getNum();
	}else if (rangoSuperior.isIden()){ // Si es un identificador
		// Miramos si la tabla de simbolos contiene el simbolo, nos esperamos que lo haga. 
		if(scopeManager.containsSymbol(rangoSuperior.getId())){
			SymbolIF symbol = scopeManager.searchSymbol(rangoSuperior.getId()); // Obtenemos el simbolo
			if(symbol instanceof SymbolConstant && symbol.getType().getName().equals("ENTERO")){ //El simbolo tiene que ser constante y entero
				numSuperior = ((SymbolConstant)symbol).getNum_value(); // Desde la propia tabla de simbolos obtenemos el valor numerico de este simbolo
			}else {
			semanticErrorManager.semanticFatalError("El simbolo "+rangoSuperior.getId()+" no corresponde a una constante de tipo entero."); 
			}
		} else {
			semanticErrorManager.semanticFatalError("El simbolo "+rangoSuperior.getId()+" no esta contenido en la tabla de simbolos."); 
		}
	}else if (rangoSuperior.isMiembrovector()){ // Si es un miembro de vector, no puede ser utilizado en la definicion de tipos
		semanticErrorManager.semanticFatalError("El simbolo "+rangoSuperior.getId()+" no corresponde a una constante de tipo entero."); 
	}

	// Ahora que hemos obtenido los numeros, procedemos a crear el tipo
	if(numSuperior > numInferior){ // Solo crearemos el tipo si el rango superior es mayor que el inferior
		// Creamos el tipo
		TypeIF t_vector_nuevo = new TypeArray(scope, id.getLexema().toUpperCase(), numInferior, numSuperior, tipov);
		tablaTipos.addType(t_vector_nuevo); // Introducimos el tipo en la tabla de tipos
		semanticErrorManager.semanticDebug("Tipo " + id.getLexema().toUpperCase() + " con [" + ((TypeArray)t_vector_nuevo).imprimir() + "] aniadido a la tabla de tipos.");		
	} else { // Emitimos error si los rangos no encajan
		semanticErrorManager.semanticFatalError("El rango superior del vector " + id.getLexema().toUpperCase() + " es mayor que el rango inferior.");
	}
	
:} deftipos | epsilon;

tipovector ::=BOOLEANO {:
	RESULT = new Tipovector(scopeManager.searchType("BOOLEANO"), "BOOLEANO");
:} | ENTERO {:
	RESULT = new Tipovector(scopeManager.searchType("ENTERO"), "ENTERO");
:} ;

valorango ::= NUM:valor_num {:
	//Creamos el Valorango
	Valorango vr = new Valorango(Integer.parseInt(valor_num.getLexema().toUpperCase()));

	//Codigo intermedio
	TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	TemporalIF temp = tf.create();
	Value valor = new Value(Integer.parseInt(valor_num.getLexema().toUpperCase()));
	cb.addQuadruple("MV",temp,valor);
	vr.setTemporal(temp);
	vr.setIntermediateCode(cb.create());
	System.out.println("Codigo intermedio: " + vr.getIntermediateCode());

	RESULT = vr;
:} | IDEN:id {:
	// Comprobamos que el simbolo este incluido en la tabla de simbolos
	if(!scopeManager.containsSymbol(id.getLexema().toUpperCase())){
		semanticErrorManager.semanticFatalError("El simbolo "+id.getLexema().toUpperCase()+" en linea " + id.getLine() +" no esta contenido en la tabla de simbolos."); 
	}
	
	// Comprobamos que el simbolo sea un entero
	SymbolIF symbol = scopeManager.searchSymbol(id.getLexema().toUpperCase()); // Obtenemos el simbolo
	if(!symbol.getType().equals(scopeManager.searchType("ENTERO"))){ //El simbolo tiene que ser entero
		semanticErrorManager.semanticFatalError("El simbolo "+id.getLexema().toUpperCase() + " en linea " + id.getLine() +" no corresponde a un entero."); 
	}
	
	Valorango vr = new Valorango(id.getLexema().toUpperCase(), true, false);
	
	//Codigo intermedio
	TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	TemporalIF temp = tf.create();
	SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema().toUpperCase());
	if(simbolo instanceof SymbolConstant){
		Value valor = new Value(((SymbolConstant)simbolo).getNum_value());
		cb.addQuadruple("MV", temp, valor);
	} else if (simbolo instanceof SymbolVariable){
		Variable var = new Variable(id.getLexema().toUpperCase(), scopeManager.getCurrentScope()); //TODO no deberia de ser expr.getId().getscope() ?
		cb.addQuadruple("MVP", temp, var);
	}
	vr.setTemporal(temp);
	vr.setIntermediateCode(cb.create());
	System.out.println("Codigo intermedio: " + vr.getIntermediateCode());

	RESULT = vr;

:} | miembrovector:m {:
	// No comprobamos que el simbolo este incluido en la tabla de simbolos porque esto ya se hace en la regla de miembrovector
	// Comprobamos que el valor almacenado en este vector (miembrovector) sea entero, ya que valorango tiene que ser un entero
	TypeIF tipoVector = scopeManager.searchSymbol(m.getId()).getType();
	if(tipoVector instanceof TypeArray){
		if(!((TypeArray)tipoVector).getTipo().getTipo().equals(scopeManager.searchType("ENTERO"))){ // Si no es de tipo entero, emitimos un error
			semanticErrorManager.semanticFatalError("El tipo del miembro del vector que ejerce de rango en otro miembro de un vector (ejemplo v1[v2[1]]) no corresponde a un entero.");
		}
	}else{
		semanticErrorManager.semanticFatalError("El tipo del miembro del vector no corresponde a TypeArray.");
	}

	Valorango vr = new Valorango(m.getId(), false, true);

	// Codigo intermedio
	vr.setTemporal(m.getTemporal());
	vr.setIntermediateCode(m.getIntermediateCode());

	RESULT = vr;
:};

secciontipos ::= COMIENZODECLTIPOS deftipos | epsilon; 

/*================================================*
 *==========DEFINICION DE VARIABLES===============*
 *================================================*/

// Definición de variables
tipovariable ::= BOOLEANO {:
	RESULT = new Tipovariable(scopeManager.searchType("BOOLEANO"), "BOOLEANO");
:}| ENTERO {:
	RESULT = new Tipovariable(scopeManager.searchType("ENTERO"), "ENTERO");
:}| IDEN:id {:
	// Recuperamos el ambito
	ScopeIF scope = scopeManager.getCurrentScope();

	// Comprobamos si la tabla de tipos contiene el tipo.
	if(scopeManager.containsType(id.getLexema().toUpperCase())){ //Si lo contiene, creamos el no terminal tipovariable para seguir adelante
		RESULT = new Tipovariable(scopeManager.searchType(id.getLexema().toUpperCase()), id.getLexema().toUpperCase());
	} else { // Si no lo contiene, lanzamos error
		semanticErrorManager.semanticFatalError("Tipo " + id.getLexema().toUpperCase() + " en linea " + id.getLine() + " no esta incluido en la tabla de tipos anteriormente, error.");
	}
:};

selectorvalororeferencia ::=  PARAMETROVALOR IDEN:id {: // Paso por referencia
	RESULT = new Selectorvalororeferencia(id.getLexema().toUpperCase(), false);
:} | expresion:ex {: // Paso por valor
	Selectorvalororeferencia svor = new Selectorvalororeferencia(ex.getId(), true);
	svor.setTipo(ex.getTipo());
	RESULT = svor;
:};

defvariables ::= listavariables:listVariables DELIMFUNC:d tipovariable:tipo puntoycomaopcional defvariables:listVariable {:
	if( !(tipo.getTipo() instanceof TypeArray || tipo.getTipo() instanceof TypeSimple) ){
		semanticErrorManager.semanticFatalError("El tipo " + tipo.getTipo().getName() + " en linea " + d.getLine() + " no es TypeArray o TypeSimple.");
	}
	// Añado las variables a defvariables y devuelvo defvariables
	if(listVariable == null){ // Si la lista esta vacia, creamos nueva
		RESULT = new Defvariables(tipo.getTipo(), (ArrayList<Selectorvalororeferencia>)(listVariables.getListaV())); 
	} else { // Si la lista contiene elementos, añadimos elementos
		listVariable.putParTipoVariable(tipo.getTipo(), (ArrayList<Selectorvalororeferencia>)(listVariables.getListaV()));
		RESULT = listVariable;
	}
:} | epsilon {:
	RESULT = new Defvariables();
:}; 

listavariables ::= selectorvalororeferencia:selector DIDENTIFICADORES listavariables:listaV {:
	listaV.addElemento(selector);
	RESULT = listaV; 
:} | selectorvalororeferencia:selector {:
	RESULT = new Listavariables(selector);
:} | epsilon {:
	RESULT = new Listavariables();
:};

seccionvariables ::= DECLVARIABLES:dc defvariables:listVariables {: 
	// Obtenemos el ambito y la tabla de simbolos
	ScopeIF scope = scopeManager.getCurrentScope();
	SymbolTableIF symbolTable = scope.getSymbolTable();

	semanticErrorManager.semanticDebug("Variables creadas con su correspondiente tipo: "+listVariables.toString());

	ArrayList<Selectorvalororeferencia> listaAux = listVariables.getListaVariablesConTipo();

	// Vamos recorriendo cada elemento de la lista de Selectorvalororeferencia
	for(int x = 0; x < listaAux.size(); x++){
		Selectorvalororeferencia variable = listaAux.get(x); // obtenemos cada Selectorvalororeferencia
		if(variable.getId() == null){ // Si es null, no es un IDEN por lo que lanzamos error
			semanticErrorManager.semanticFatalError("Se ha detectado una notacion de declaracion de variable no autorizada. Asegurar que todas las variables sean declaradas con identificadores.");
		}else{ // Si no es null, es un IDEN
			if(variable.isPorValor()){ //comprobamos que es por valor				
				errorSiExisteSimbolo(variable.getId(), dc.getLine()); // Error si existe en la tabla de simbolos
				errorSiExisteTipo(variable.getId(), dc.getLine()); // Error si existe en la tabla de tipos
				SymbolVariable symbol = new SymbolVariable(scope, variable.getId(), variable.getTipo());
				symbolTable.addSymbol(symbol);
			}else{ // si no es por valor, lanzamos error
				semanticErrorManager.semanticFatalError("No se puede declarar la variable " + variable.getId() + ", es por referencia.");
			}
		}
	}

:}| epsilon  ;

puntoycomaopcional ::= DSENTENCIAS | epsilon;


/*================================================*
 *================SUBPROGRAMAS====================*
 *================================================*/

//reglas de subprogramas
tiporetornofuncion ::= tipovector:t {:
	RESULT = t;
:} ; 

procedimiento ::= COMIENZOPROCEDIMIENTO IDEN:id PIZQUIERDO defvariables:listaVar {:
	// Obtenemos el ambito, la tabla de tipos y la tabla de simbolos
	ScopeIF scope = scopeManager.getCurrentScope();
	SymbolTableIF symbolTable = scope.getSymbolTable();
	TypeTableIF typeTable = scope.getTypeTable();

	// Invocamos los metodos que lanzan un error si el id esta anteriormente declarado bien en la tabla de simbolos o bien en la tabla de tipos
	errorSiExisteSimbolo(id.getLexema().toUpperCase(), id.getLine());
	errorSiExisteTipo(id.getLexema().toUpperCase(), id.getLine());
	
	// Creamos el tipo y el simbolo del procedimiento
	TypeProcedure tp = new TypeProcedure(scope, id.getLexema().toUpperCase());
	tp.setListaParametros(listaVar.getListaVariablesConTipo());
	typeTable.addType(id.getLexema().toUpperCase(), tp);
	SymbolProcedure sp = new SymbolProcedure(scope, id.getLexema().toUpperCase(), tp);
	sp.setListaParametros(listaVar.getListaVariablesConTipo());
	symbolTable.addSymbol(id.getLexema().toUpperCase(), sp);

	// Creamos el ambito con el nombre del procedimiento y emitimos el mensaje de comprobación
	scopeManager.openScope(id.getLexema().toUpperCase());
	scope = scopeManager.getCurrentScope();
	semanticErrorManager.semanticDebug("El nombre del nuevo ambito es: " + scope.getName() + " con el nivel: " + scope.getLevel());	
	

	// listaVar se trata de una clase que contiene un Arraylist<Selectorvalororeferencia> que le pasamos al procedimiento. Cogeremos cada variable uno a uno e incluiremos en la tabla de símbolos.
	if(listaVar != null){
		// Obtenemos la tabla de simbolos
		symbolTable = scope.getSymbolTable();

		// Primero recuperamos el ArrayList
		ArrayList<Selectorvalororeferencia> listaAux = listaVar.getListaVariablesConTipo();

		// Recorremos la lista e introducimos las variables en la tabla de simbolos
		for(int x = 0; x < listaAux.size(); x++){
			Selectorvalororeferencia variable = listaAux.get(x);
			errorSiExisteSimbolo(variable.getId(), id.getLine()); //TODO aqui tambien deberia de incluir un errorSiExisteTipo? revisar (y en funcion tambien)

			// Comprobacion de que no se pasa por valor ningun vector completo, esta prohibido
			if(variable.isPorValor() && variable.getTipo() instanceof TypeArray){
				semanticErrorManager.semanticFatalError("No se puede pasar por valor el vector completo " + variable.getId());
			}

			// Crear e incluir el simbolo al symbolTable
			SymbolParameter symbol = new SymbolParameter(scope, variable.getId(), variable.getTipo());
			symbolTable.addSymbol(symbol);
		}
	}
:} PDERECHO DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO sentencia listaSentencias FINBLOQUESENTENCIAS DSENTENCIAS {:
	// Cerramos el ambito actual (current scope)
	scopeManager.closeScope();
	semanticErrorManager.semanticDebug("Se ha cerrado el ambito actual.");
:};

funcion ::= DECLAREFUNCION IDEN:id PIZQUIERDO defvariables:listaVar PDERECHO DELIMFUNC tiporetornofuncion:tipo {:
	// Obtenemos el ambito, la tabla de tipos y la tabla de simbolos
	ScopeIF scope = scopeManager.getCurrentScope();
	SymbolTableIF symbolTable = scope.getSymbolTable();
	TypeTableIF typeTable = scope.getTypeTable();

	// Invocamos los metodos que lanzan un error si el id esta anteriormente declarado bien en la tabla de simbolos o bien en la tabla de tipos
	errorSiExisteSimbolo(id.getLexema().toUpperCase(), id.getLine());
	errorSiExisteTipo(id.getLexema().toUpperCase(), id.getLine());
	
	// Creamos el tipo y el simbolo de la funcion
	TypeFunction tf = new TypeFunction(scope, id.getLexema().toUpperCase(), tipo.getNombre_tipo(), listaVar.getListaVariablesConTipo());
	typeTable.addType(id.getLexema().toUpperCase(), tf);
	SymbolFunction sf = new SymbolFunction(scope, id.getLexema().toUpperCase(), tf, tipo.getNombre_tipo(), listaVar.getListaVariablesConTipo());
	symbolTable.addSymbol(id.getLexema().toUpperCase(), sf);
	
	// Creamos el ambito con el nombre de la funcion y emitimos el mensaje de comprobación
	scopeManager.openScope(id.getLexema().toUpperCase());
	scope = scopeManager.getCurrentScope();
	semanticErrorManager.semanticDebug("El nombre del nuevo ambito es: " + scope.getName() + " con el nivel: " + scope.getLevel());
	

	// listVar se trata de una clase que contiene un ArrayList de variables que le pasamos a la funcion. Cogeremos cada variable uno a uno e incluiremos en la tabla de símbolos.
	if(listaVar != null){
		// Obtenemos la tabla de simbolos
		symbolTable = scope.getSymbolTable();

		// Primero recuperamos el ArrayList
		ArrayList<Selectorvalororeferencia> listaAux = listaVar.getListaVariablesConTipo();

		// Recorremos la lista e introducimos las variables en la tabla de simbolos
		for(int x = 0; x < listaAux.size(); x++){
			Selectorvalororeferencia variable = listaAux.get(x);
			// Comprobamos si la tabla de simbolos contiene el simbolo
			errorSiExisteSimbolo(variable.getId(), id.getLine());

			// Comprobacion de que no se pasa por valor ningun vector completo, esta prohibido
			if(variable.isPorValor() && variable.getTipo() instanceof TypeArray){
				semanticErrorManager.semanticFatalError("No se puede pasar por valor el vector completo " + variable.getId());
			}

			// Crear e incluir el simbolo al symbolTable
			SymbolParameter symbol = new SymbolParameter(scope, variable.getId(), variable.getTipo());
			symbolTable.addSymbol(symbol);
		}
	}
	
	// Comprobar que exista el tipo de retorno. Para ello, si no lo contiene, lanzaremos un error.
	if(!scopeManager.containsType(tipo.getNombre_tipo())){
		semanticErrorManager.semanticFatalError("Tipo " + tipo.getNombre_tipo() + " de retorno de funcion no existe, error.");
	} //es posible que no sea necesario hacer esta comprobacion, porque ya tenemos el tipo en su sitio y cualquier fallo lo detectaria la sintaxis

:} DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO sentenciaFuncion:sentFun listaSentenciasFuncion:listaSentFun {:
	// Comprobar si hay alguna sentencia de devolver en las sentencias de esta funcion
	if(!(sentFun.isContieneSentenciaDevolver() || listaSentFun.isContieneSentenciaDevolver())){
		semanticErrorManager.semanticFatalError("La funcion " + id.getLexema().toUpperCase() + " no tiene sentencia de devolver o existe una ruta de ejecucion que no alcanza una sentencia devolver, error.");
	}

:} FINBLOQUESENTENCIAS DSENTENCIAS {:
	// Cerramos el ambito actual (current scope)
	scopeManager.closeScope();
	semanticErrorManager.semanticDebug("Se ha cerrado el ambito actual.");
:} ;
selectorpof ::= procedimiento | funcion ;
defsubprograma ::=selectorpof  defsubprograma | epsilon ;
seccionsubprograma ::=COMIENZOSUBPROGRAMAS  defsubprograma  | epsilon ;

/*================================================*
 *==============PROGRAMA PRINCIPAL================*
 *================================================*/

// Definición de programa principal
defprincipal ::= COMIENZOPROGRAMA IDEN:id {:

	// Creamos el ambito global con el nombre del programa principal
	scopeManager.openScope(id.getLexema().toUpperCase());
	ScopeIF scope = scopeManager.getCurrentScope();
	// Comprobaciones para ver si el ambito se ha creado correctamente
	semanticErrorManager.semanticDebug("El nombre del nuevo ambito es: " + scope.getName());
	semanticErrorManager.semanticDebug("El nivel del nuevo ambito es: " + scope.getLevel()); // El nivel esperado es 0
	
	// Obtencion de la tabla de tipos y simbolos
	SymbolTableIF symbolTable = scope.getSymbolTable(); //BORRAR No estoy segura para que lo recupero si no se usa
	TypeTableIF typeTable = scope.getTypeTable();
	
	// Introducimos los tipos entero y booleano que describe el enunciado
	TypeSimple tsEntero = new TypeSimple(scope, "ENTERO");
	typeTable.addType("ENTERO",tsEntero);
	TypeSimple tsBooleano = new TypeSimple(scope, "BOOLEANO");
	typeTable.addType("BOOLEANO",tsBooleano);
	
:} DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO listaSentencias:listaS FINBLOQUESENTENCIAS FINPROGRAMA {:
	RESULT = listaS;
:};

/*================================================*
 *==================EXPRESIONES===================*
 *================================================*/

// Expresiones
expresion ::=  expresion:e1 MENORQUE  expresion:e2 {:
	Expresion expr = new Expresion(); // Creamos la expresion

	// Comprobaciones semanticas
	// Comprobamos que los tipos no sean null para no tener un null pointer exception
	if(e1.getTipo() != null && e2.getTipo() != null){
		if(e1.getTipo().getName().equals("ENTERO") && e2.getTipo().getName().equals("ENTERO")){
			expr.setTipo(scopeManager.searchType("BOOLEANO"));// Establecemos el tipo
		} else {
			semanticErrorManager.semanticFatalError("Uno o ambos de los tipos de la expresion " + e1.getId() + " < " + e2.getId() + " no es un entero.");
		}
	}else{
		semanticErrorManager.semanticFatalError("Uno o ambos de los tipos de la expresion " + e1.getId() + " < " + e2.getId() + " es null.");
	}


	// Codigo intermedio
	TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	TemporalIF tempE1 = e1.getTemporal();
	cb.addQuadruples(e1.getIntermediateCode());
	TemporalIF tempE2 = e2.getTemporal();
	cb.addQuadruples(e2.getIntermediateCode());
	TemporalIF tempResultado = tf.create();
	cb.addQuadruple("LS", tempResultado, tempE1, tempE2);
	expr.setTemporal(tempResultado);
	expr.setIntermediateCode(cb.create());
	System.out.println("Codigo intermedio: " + expr.getIntermediateCode());
	
	RESULT = expr;

:} |  expresion:e1 IGUALDAD  expresion:e2 {:
	Expresion expr = new Expresion(); // Creamos la expresion

	// Comprobaciones semanticas
	// Comprobamos que los tipos no sean null para no tener un null pointer exception
	if(e1.getTipo() != null && e2.getTipo() != null){
		if(e1.getTipo().getName().equals("ENTERO") && e2.getTipo().getName().equals("ENTERO")){
			expr.setTipo(scopeManager.searchType("BOOLEANO"));// Establecemos el tipo
			RESULT = expr; // Propagamos la expresion
		} else {
			semanticErrorManager.semanticFatalError("Uno o ambos de los tipos de la expresion " + e1.getId() + " == " + e2.getId() + " no es un entero.");
		}
	}else{
		semanticErrorManager.semanticFatalError("Uno o ambos de los tipos de la expresion " + e1.getId() + " == " + e2.getId() + " es null.");
	}

	// Codigo intermedio
	TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	TemporalIF tempE1 = e1.getTemporal();
	cb.addQuadruples(e1.getIntermediateCode());
	TemporalIF tempE2 = e2.getTemporal();
	cb.addQuadruples(e2.getIntermediateCode());
	TemporalIF tempResultado = tf.create();
	cb.addQuadruple("EQ", tempResultado, tempE1, tempE2);
	expr.setTemporal(tempResultado);
	expr.setIntermediateCode(cb.create());
	System.out.println("Codigo intermedio: " + expr.getIntermediateCode());
	
	RESULT = expr;

:} | IDEN:id {:
	Expresion expr = new Expresion(id.getLexema().toUpperCase()); // Creamos la expresion
	if(scopeManager.containsSymbol(expr.getId())){ // Si existe ya en la tabla de simbolos
		expr.setTipo(scopeManager.searchSymbol(expr.getId()).getType());// Establecemos el tipo
		semanticErrorManager.semanticDebug(expr);
	}

	// Codigo intermedio
	TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	TemporalIF temp = tf.create();
	SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema().toUpperCase());
	if(simbolo instanceof SymbolConstant){
		Value valor = new Value(((SymbolConstant)simbolo).getNum_value());
		cb.addQuadruple("MV", temp, valor);
	} else if (simbolo instanceof SymbolVariable){
		Variable var = new Variable(id.getLexema().toUpperCase(), scopeManager.getCurrentScope()); //TODO no deberia de ser expr.getId())).getScope()
		cb.addQuadruple("MVP", temp, var);
	}
	expr.setTemporal(temp);
	expr.setIntermediateCode(cb.create());
	System.out.println("Codigo intermedio: " + expr.getIntermediateCode());
	RESULT = expr;

:} | llamadafuncion:lf {:
	Expresion expr = new Expresion(); // Creamos la expresion
	expr.setTipo(lf.getTipo());// Establecemos el tipo

	// Codigo intermedio
	expr.setTemporal(lf.getTemporal());
	expr.setIntermediateCode(lf.getIntermediateCode());

	RESULT = expr;

:} | CIERTO {:
	Expresion expr = new Expresion(); // Creamos la expresion
	expr.setTipo(scopeManager.searchType("BOOLEANO"));// Establecemos el tipo
	expr.setValorBooleano(true); // Establecemos el valor
	expr.setEsValorConstante(true);

	// Codigo intermedio
	TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	TemporalIF temp = tf.create();
	Value valor = new Value(1);
	cb.addQuadruple("MV", temp, valor);
	expr.setTemporal(temp);
	expr.setIntermediateCode(cb.create());
	System.out.println("Codigo intermedio: " + expr.getIntermediateCode());
	RESULT = expr;

:} | FALSO {:
	Expresion expr = new Expresion(); // Creamos la expresion
	expr.setTipo(scopeManager.searchType("BOOLEANO"));// Establecemos el tipo
	expr.setValorBooleano(false); // Establecemos el valor
	expr.setEsValorConstante(true);

	// Codigo intermedio
	TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	TemporalIF temp = tf.create();
	Value valor = new Value(0);
	cb.addQuadruple("MV", temp, valor);
	expr.setTemporal(temp);
	expr.setIntermediateCode(cb.create());
	System.out.println("Codigo intermedio: " + expr.getIntermediateCode());
	RESULT = expr;

:} | miembrovector:mv {:
	Expresion expr = new Expresion(); // Creamos la expresion
	expr.setTipo(mv.getTipo());// Establecemos el tipo

	// Codigo intermedio
	expr.setTemporal(mv.getTemporal());
	expr.setIntermediateCode(mv.getIntermediateCode());

	RESULT = expr;

:} | NUM:valor_num {:
	Expresion expr = new Expresion(); // Creamos la expresion
	expr.setTipo(scopeManager.searchType("ENTERO"));// Establecemos el tipo
	expr.setValorEntero(Integer.parseInt(valor_num.getLexema().toUpperCase()));
	expr.setEsValorConstante(true);

	// Codigo intermedio
	TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	TemporalIF temp = tf.create();
	Value valor = new Value(Integer.parseInt(valor_num.getLexema().toUpperCase()));
	cb.addQuadruple("MV", temp, valor);
	expr.setTemporal(temp);
	expr.setIntermediateCode(cb.create());
	System.out.println("Codigo intermedio: " + expr.getIntermediateCode());
	RESULT = expr;
:} | expresionlvl2:ex {:
	RESULT = ex;
:};

expresionlvl2 ::=  expresion:e1 SUMA expresion:e2 {:
	Expresion expr = new Expresion(); // Creamos la expresion

	// Comprobaciones semanticas
	// Comprobamos que los tipos no sean null para no tener un null pointer exception
	if(e1.getTipo() != null && e2.getTipo() != null){
		if(e1.getTipo().getName().equals("ENTERO") && e2.getTipo().getName().equals("ENTERO")){
			expr.setTipo(scopeManager.searchType("ENTERO"));// Establecemos el tipo
		} else {
			semanticErrorManager.semanticFatalError("Uno o ambos de los tipos de la expresion " + e1.getId() + " + " + e2.getId() + " no es un entero.");
		}
	}else{
		semanticErrorManager.semanticFatalError("Uno o ambos de los tipos de la expresion " + e1.getId() + " + " + e2.getId() + " es null.");
	}

	// Codigo intermedio
	TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	TemporalIF tempE1 = e1.getTemporal();
	cb.addQuadruples(e1.getIntermediateCode());
	TemporalIF tempE2 = e2.getTemporal();
	cb.addQuadruples(e2.getIntermediateCode());
	TemporalIF tempResultado = tf.create();
	cb.addQuadruple("ADD", tempResultado, tempE1, tempE2);
	expr.setTemporal(tempResultado);
	expr.setIntermediateCode(cb.create());
	System.out.println("Codigo intermedio: " + expr.getIntermediateCode());

	RESULT = expr; // Propagamos la expresion

:} | expresionlvl3:ex {:
	RESULT = ex;
:} ;

expresionlvl3 ::=  expresion:e1 YLOGICA expresion:e2 {:
	Expresion expr = new Expresion(); // Creamos la expresion

	// Comprobaciones semanticas
	// Comprobamos que los tipos no sean null para no tener un null pointer exception
	if(e1.getTipo() != null && e2.getTipo() != null){
		if(e1.getTipo().getName().equals("BOOLEANO") && e2.getTipo().getName().equals("BOOLEANO")){
			expr.setTipo(scopeManager.searchType("BOOLEANO"));// Establecemos el tipo
		} else {
			semanticErrorManager.semanticFatalError("Uno o ambos de los tipos de la expresion " + e1.getId() + " y " + e2.getId() + " no es un booleano.");
		}
	}else{
		semanticErrorManager.semanticFatalError("Uno o ambos de los tipos de la expresion " + e1.getId() + " y " + e2.getId() + " es null.");
	}

	// Codigo intermedio
	TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	TemporalIF tempE1 = e1.getTemporal();
	cb.addQuadruples(e1.getIntermediateCode());
	TemporalIF tempE2 = e2.getTemporal();
	cb.addQuadruples(e2.getIntermediateCode());
	TemporalIF tempResultado = tf.create();
	cb.addQuadruple("AND", tempResultado, tempE1, tempE2);
	expr.setTemporal(tempResultado);
	expr.setIntermediateCode(cb.create());
	System.out.println("Codigo intermedio: " + expr.getIntermediateCode());

	RESULT = expr; // Propagamos la expresion

:} |  expresion:e1 PRODUCTO expresion:e2 {:
	Expresion expr = new Expresion(); // Creamos la expresion

	// Comprobaciones semanticas
	// Comprobamos que los tipos no sean null para no tener un null pointer exception
	if(e1.getTipo() != null && e2.getTipo() != null){
		if(e1.getTipo().getName().equals("ENTERO") && e2.getTipo().getName().equals("ENTERO")){
			expr.setTipo(scopeManager.searchType("ENTERO"));// Establecemos el tipo
		} else {
			semanticErrorManager.semanticFatalError("Uno o ambos de los tipos de la expresion " + e1.getId() + " * " + e2.getId() + " no es un entero.");
		}
	}else{
		semanticErrorManager.semanticFatalError("Uno o ambos de los tipos de la expresion " + e1.getId() + " * " + e2.getId() + " es null.");
	}

	// Codigo intermedio
	TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	TemporalIF tempE1 = e1.getTemporal();
	cb.addQuadruples(e1.getIntermediateCode());
	TemporalIF tempE2 = e2.getTemporal();
	cb.addQuadruples(e2.getIntermediateCode());
	TemporalIF tempResultado = tf.create();
	cb.addQuadruple("MUL", tempResultado, tempE1, tempE2);
	expr.setTemporal(tempResultado);
	expr.setIntermediateCode(cb.create());
	System.out.println("Codigo intermedio: " + expr.getIntermediateCode());

	RESULT = expr; // Propagamos la expresion

:} | expresionlvl4:ex {:
	RESULT = ex;
:};

expresionlvl4 ::= NOLOGICO  expresion:e1 {:
	Expresion expr = new Expresion(); // Creamos la expresion

	// Comprobaciones semanticas
	// Comprobamos que los tipos no sean null para no tener un null pointer exception
	if(e1.getTipo() != null){
		if(e1.getTipo().getName().equals("BOOLEANO")){
			expr.setTipo(scopeManager.searchType("BOOLEANO"));// Establecemos el tipo
		} else {
			semanticErrorManager.semanticFatalError("El tipo de la expresion " + e1.getId() + " no es un booleano.");
		}
	}else{
		semanticErrorManager.semanticFatalError("El tipo de la expresion " + e1.getId() + " es null.");
	}

	// Codigo intermedio
	TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	TemporalIF tempE1 = e1.getTemporal();
	cb.addQuadruples(e1.getIntermediateCode());
	TemporalIF tempResultado = tf.create();
	cb.addQuadruple("NEG", tempResultado, tempE1);
	expr.setTemporal(tempResultado);
	expr.setIntermediateCode(cb.create());
	System.out.println("Codigo intermedio: " + expr.getIntermediateCode());

	RESULT = expr; // Propagamos la expresion

:} | expresionlvl5:ex {:
	RESULT = ex;
:} ;

expresionlvl5 ::= PIZQUIERDO expresion:expr PDERECHO {:
	RESULT = expr;
:} | CIZQUIERDO expresion:expr CDERECHO {:
	RESULT = expr;
:} ;

/*================================================*
 *================ACCESO A VECTORES===============*
 *================================================*/

// Acceso a vectores
miembrovector ::= IDEN:id CIZQUIERDO valorango:vr CDERECHO {:
	// Comprobamos si el miembrovector esta previamente incluido en la tabla de simbolos
	if(!scopeManager.containsSymbol(id.getLexema().toUpperCase())){
		semanticErrorManager.semanticFatalError("El simbolo "+ id.getLexema().toUpperCase()+ " no esta contenido en la tabla de simbolos."); 
	}

	// Obtenemos el tipo del vector
	TypeIF tipoVector = (scopeManager.searchSymbol(id.getLexema().toUpperCase())).getType();

	// En el caso de que valorango sea un numero, comprobamos que valorango este dentro del rango inferior y superior del vector
	if(vr.isNum()){
		if(tipoVector instanceof TypeArray){
			int indiceAcceder = vr.getNum();
			int rangoInferior = ((TypeArray)tipoVector).getRangoInferior();
			int rangoSuperior = ((TypeArray)tipoVector).getRangoSuperior();
			
			if(!(indiceAcceder <= rangoSuperior && indiceAcceder >= rangoInferior)){
				semanticErrorManager.semanticFatalError("El indice al que se quiere acceder en el vector "+ id.getLexema().toUpperCase()+ " en la linea "+ id.getLine() + " no esta contenido dentro de los limites del rango del tipo del vector.");
			}
		}else{
			semanticErrorManager.semanticFatalError("El simbolo "+ id.getLexema().toUpperCase()+ " no es una instancia de TypeArray.");
		}
	}
	// En el caso de que valorango sea un identificador, comprobamos que el identificador sea una constante, y si es una constante, que este dentro del rango inferior y superior del vector
	if(vr.isIden()){ 
		if(scopeManager.searchSymbol(vr.getId()) instanceof SymbolConstant){
			if(tipoVector instanceof TypeArray){
				int indiceAcceder = ((SymbolConstant)scopeManager.searchSymbol(vr.getId())).getNum_value();
				int rangoInferior = ((TypeArray)tipoVector).getRangoInferior();
				int rangoSuperior = ((TypeArray)tipoVector).getRangoSuperior();
				
				if(!(indiceAcceder <= rangoSuperior && indiceAcceder >= rangoInferior)){
					semanticErrorManager.semanticFatalError("El indice al que se quiere acceder en el vector "+ id.getLexema().toUpperCase()+ " en la linea "+ id.getLine() + " no esta contenido dentro de los limites del rango del tipo del vector.");
				}
			}else{
				semanticErrorManager.semanticFatalError("El simbolo "+ id.getLexema().toUpperCase()+ " no es una instancia de TypeArray.");
			}
		}
	}

	// Creamos el miembro del vector y establecemos su tipo
	Miembrovector mv = new Miembrovector(id.getLexema().toUpperCase());
	if(!(tipoVector instanceof TypeArray)){ //Si no es instancia de TypeArray lanzamos error
		semanticErrorManager.semanticFatalError("El simbolo "+ id.getLexema().toUpperCase()+ " no es una instancia de TypeArray.");
	}
	mv.setTipo(((TypeArray)tipoVector).getTipo().getTipo()); // Obtenemos el tipo de los miembros del vector y establecemos al mv

	//Codigo intermedio
	TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(vr.getIntermediateCode());
	TemporalIF temp = tf.create();
	TemporalIF temp1 = tf.create();
	TemporalIF temp2 = tf.create();
	TemporalIF tempPosicion = vr.getTemporal(); // Se trata del desplazamiento que usaremos para cambiar de posicion y acceder diferentes campos del vector
	SymbolIF simboloVector = scopeManager.searchSymbol(id.getLexema().toUpperCase()); // Obtenemos el simbolo del vector
	Variable var = new Variable(id.getLexema().toUpperCase(), simboloVector.getScope()); //Creamos una variable para el simbolo del vector
	cb.addQuadruple("MVA", temp1, var); // Se trata de la direccion base de la variable, donde esta el registro de la primera posicion
	cb.addQuadruple("ADD", temp2, temp1, tempPosicion); //Sumamos el desplazamiento para acceder a la posicion
	mv.setTemporal(temp2);
	mv.setIntermediateCode(cb.create());

	System.out.println("Codigo intermedio: " + mv.getIntermediateCode());

	RESULT = mv;
:};

/*================================================*
 *============SENTENCIAS DE ASIGNACION============*
 *================================================*/
 
parteizquierdaasignacion ::= IDEN:id {:
	// Comprobamos si el identificador esta previametne incluido en la tabla de simbolos
	if(!scopeManager.containsSymbol(id.getLexema().toUpperCase())){
		semanticErrorManager.semanticFatalError("El simbolo "+ id.getLexema().toUpperCase()+ " no esta contenido en la tabla de simbolos."); 
	} 

	Parteizquierdaasignacion pizq = new Parteizquierdaasignacion(id.getLexema().toUpperCase());
	pizq.setTipo((scopeManager.searchSymbol(id.getLexema().toUpperCase())).getType()); // Obtenemos el tipo del simbolo y establecemos al pizq
	

	// Codigo intermedio
	TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	TemporalIF temp = tf.create();
	Variable var = new Variable(id.getLexema().toUpperCase(), (scopeManager.searchSymbol(id.getLexema().toUpperCase())).getScope());
	cb.addQuadruple("MVA", temp, var);
	pizq.setTemporal(temp);
	pizq.setIntermediateCode(cb.create());
	System.out.println("Codigo intermedio: " + pizq.getIntermediateCode());

	RESULT = pizq;

:} | miembrovector:mv {:
	Parteizquierdaasignacion pizq = new Parteizquierdaasignacion(mv.getId());
	pizq.setTipo(mv.getTipo());

	// Codigo intermedio 
	pizq.setTemporal(mv.getTemporal());
	pizq.setIntermediateCode(mv.getIntermediateCode());

	RESULT = pizq;
:};

sentenciadeasignacion ::= parteizquierdaasignacion:pizq ASIGNACION:as parametroasignacion:expr DSENTENCIAS {:
	//Comprobaciones semanticas
	// La parte izquierda tiene que ser instancia de SymbolVariable o SymbolParameter, y tiene que ser una instancia de tipo simple
	if((scopeManager.searchSymbol(pizq.getId())instanceof SymbolVariable || scopeManager.searchSymbol(pizq.getId())instanceof SymbolParameter) && (pizq.getTipo() instanceof TypeSimple)){
		// El tipo de pizq tiene que coincidir con el tipo de expr
		if(pizq.getTipo().getName().equals(expr.getTipo().getName())){
			semanticErrorManager.semanticDebug("Asignacion en linea " + as.getLine() + " OK, coinciden los tipos.");
		}else{
			semanticErrorManager.semanticFatalError("Asignacion en linea " + as.getLine() + " erroneo, no coinciden los tipos.");
		}
	}else{
		semanticErrorManager.semanticFatalError(pizq.getId()+ " no puede estar en la parte izquierda de una sentencia de asignacion porque no es o SymbolVariable o SymbolParameter o del tipo TypeSimple.");
	}

	// Codigo intermedio
	Sentencia s = new Sentencia();
	//TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	

	// Recuperamos el temporal de la parte izquierda y su codigo intermedio
	TemporalIF tempIzq = pizq.getTemporal();
	cb.addQuadruples(pizq.getIntermediateCode());

	// Recuperamos el temporal de la parte derecha y su codigo intermedio
	TemporalIF tempDch = expr.getTemporal();
	cb.addQuadruples(expr.getIntermediateCode());

	// Creamos la cuadrupla y establecemos el codigo intermedio
	cb.addQuadruple("STP", tempIzq, tempDch);
	s.setTemporal(tempIzq); //creo que no es necesario
	s.setIntermediateCode(cb.create());
	System.out.println("Codigo intermedio: " + s.getIntermediateCode());

	/* BORRAR? //AQUI - como compruebo si es variable o parametro si lo que tengo es una expresion
	if(expr.isEsValorConstante()){ // si es una constante, obtenemos el valor para meter en el objeto de tipo valor y movemos el valor a un temporal
		TemporalIF tempDch = expr.getTemporal();
		cb.addQuadruples(expr.getIntermediateCode());

		//TODO mover esto fuera del IF, al final del todo
		TemporalIF tempFinal = tf.create();
		cb.addQuadruple("STP", tempIzq, tempDch);
		s.setTemporal(tempIzq); //creo que no es necesario
		s.setIntermediateCode(cb.create());
		System.out.println("Codigo intermedio: " + s.getIntermediateCode());
	} else { //si es variable, indicamos el nombre de variable y ambito donde esta y movemos el puntero de la variable al temporal
		//AQUI hay dos casos: puede ser un iden o puede ser un resultado de una expresion. Los tengo que distinguir
		//aqui Antes de hacer esto, tiene sentido hacer todas las expresiones y luego aqui traducirlo en base a las expresiones

		//voy a hacer como si fuera un IDEN, esto queda pendiente de revisar
	}*/

	RESULT = s;
	

:}; 

parametroasignacion ::= expresion:e {:
	RESULT = e;
:} ;

/*================================================*
 *===============LLAMADA A FUNCION================*
 *================================================*/
 // Nota - Esta seccion, pese a llamarse llamada a funcion, tambien sirve para realizar las llamadas a los procedimientos.

parametrofuncionoproc ::=     listavariables:lv {:
	RESULT = lv;
:} ;

llamadafuncion ::= IDEN:id PIZQUIERDO parametrofuncionoproc:lv PDERECHO {:
	// Comprobamos si el identificador esta previamente incluido en la tabla de simbolos como SymbolProcedure o SymbolFunction
	if(!scopeManager.containsSymbol(id.getLexema().toUpperCase())){
		semanticErrorManager.semanticFatalError("El identificador "+ id.getLexema().toUpperCase()+ " en linea "+ id.getLine()+ " no esta contenido en la tabla de simbolos como funcion o procedimiento."); 
	}
	if(!(   scopeManager.searchSymbol(id.getLexema().toUpperCase()) instanceof SymbolProcedure || scopeManager.searchSymbol(id.getLexema().toUpperCase()) instanceof SymbolFunction  )){
		semanticErrorManager.semanticFatalError("El identificador "+ id.getLexema().toUpperCase()+ " en linea "+ id.getLine()+ " no es una funcion o un procedimiento."); 
	}

	Llamadafuncion lf = new Llamadafuncion(id.getLexema().toUpperCase());
	lf.setTipo((scopeManager.searchSymbol(id.getLexema().toUpperCase())).getType()); // Obtenemos el tipo del simbolo y establecemos al lf

	//Variables para la comprobacion de parametros
	ArrayList<Selectorvalororeferencia> listaParametrosEsperados = null;
	ArrayList<Selectorvalororeferencia> listaParametrosPasados = lv.getListaV();
		
	// Si es una funcion
	if(scopeManager.searchSymbol(id.getLexema().toUpperCase()) instanceof SymbolFunction){
		//establecemos el tipo de retorno como tipo
		SymbolFunction sf = (SymbolFunction)scopeManager.searchSymbol(id.getLexema().toUpperCase());
		lf.setTipo(scopeManager.searchType(sf.getTipoRetorno()));

		// Obtenemos la lista de parametros esperados de la funcion
		listaParametrosEsperados = sf.getListaParametros();
	}

	// Si es un procedimiento
	if(scopeManager.searchSymbol(id.getLexema().toUpperCase()) instanceof SymbolProcedure){
		// Obtenemos la lista de parametros esperados del procedimiento
		SymbolProcedure sp = (SymbolProcedure)scopeManager.searchSymbol(id.getLexema().toUpperCase());
		listaParametrosEsperados = sp.getListaParametros();
	}

	// Comparamos ambas listas de parametros
	if(listaParametrosEsperados.size() != listaParametrosPasados.size()){ // Comprobacion en numero
		semanticErrorManager.semanticFatalError("El numero de parametros de "+ id.getLexema().toUpperCase()+ " no corresponde a lo esperado."); 
	}
	
	for (int x = 0; x < listaParametrosEsperados.size(); x++){ // Comprobacion en tipo y orden
		Selectorvalororeferencia parametroEsperado = listaParametrosEsperados.get(x);
		Selectorvalororeferencia parametroPasado = listaParametrosPasados.get(x);

		if(!parametroPasado.isPorValor()){
			semanticErrorManager.semanticFatalError("Uno de los parametros pasados a "+ id.getLexema().toUpperCase()+ " en linea "+id.getLine()+ " es por referencia. No se puede pasar parametros por referencia en llamadas a funciones.");
		}

		if(!parametroEsperado.getTipo().getName().equals(parametroPasado.getTipo().getName())){
			semanticErrorManager.semanticFatalError("Alguno o varios de los tipos u orden de los parametros de "+ id.getLexema().toUpperCase()+ " en linea " +id.getLine()+ " no corresponde a lo esperado.");
		}

		if(!parametroEsperado.isPorValor()){ // Si el parametro esperado es por referencia
		 	if(parametroPasado.getId() == null){ // El parametro pasado debe ser una variable, sino error
				 semanticErrorManager.semanticFatalError("Se ha detectado una expresion que no corresponde a una variable en una posicion de paso por referencia en "+ id.getLexema().toUpperCase()+ " en linea " +id.getLine());
			 }
		}
	}

	// Codigo intermedio
	// Le damos un 1 como valor de retorno por defecto ya que no se ha implementado esta parte
	TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	TemporalIF temp = tf.create();
	Value valor = new Value(1);
	cb.addQuadruple("MV", temp, valor);
	lf.setTemporal(temp);
	lf.setIntermediateCode(cb.create());
	System.out.println("Codigo intermedio: " + lf.getIntermediateCode());

	RESULT = lf;
:};  

sentenciallamadafuncion ::= llamadafuncion:lf DSENTENCIAS:d {:
	if(!(lf.getTipo() instanceof TypeProcedure)){
		semanticErrorManager.semanticFatalError("Se ha detectado una invocacion a funcion no autorizada en la linea "+ d.getLine()+ ". No se permite invocar funciones en sentencias.");
	}
:};

/*================================================*
 *===================SENTENCIAS===================*
 *================================================*/

sentencia ::= sentenciadeasignacion:s {:
	RESULT = s;
:} | sentenciaif {:
	Sentencia s = new Sentencia();
	s.setIntermediateCode(new ArrayList());
	RESULT = s;
:} | sentenciafor {:
	Sentencia s = new Sentencia();
	s.setIntermediateCode(new ArrayList());
	RESULT = s;
:} | sentenciaEscribir:s {:
	RESULT = s;
:} | sentenciallamadafuncion {:
	Sentencia s = new Sentencia();
	s.setIntermediateCode(new ArrayList());
	RESULT = s;
:} ;

listaSentencias ::= sentencia:s1  listaSentencias:s2list {:
	Sentencia s = new Sentencia();
	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruples(s1.getIntermediateCode());
	cb.addQuadruples(s2list.getIntermediateCode()); // respetamos el orden
	s.setIntermediateCode(cb.create());
	RESULT = s;
:} | epsilon {:
	Sentencia s = new Sentencia();
	s.setIntermediateCode(new ArrayList());
	RESULT = s;
:};

sentenciaFuncion ::= sentenciadeasignacion {:
	Sentencia s = new Sentencia();
	s.setIntermediateCode(new ArrayList());
	RESULT = s;
:} | sentenciaifFuncion:sIf {:
	RESULT = sIf;
:} | sentenciaforFuncion:sFor {:
	RESULT = sFor;
:} | sentenciaEscribir:s {:
	RESULT = s;
:} | sentenciallamadafuncion {:
	Sentencia s = new Sentencia();
	s.setIntermediateCode(new ArrayList());
	RESULT = s;
:} | sentenciaDevolver:st {:
	Sentencia s = new Sentencia();
	s.setContieneSentenciaDevolver(true);
	s.setIntermediateCode(new ArrayList());
	RESULT = s;
:};

listaSentenciasFuncion ::= sentenciaFuncion:sent listaSentenciasFuncion:listaSent {:
	if(sent.isContieneSentenciaDevolver()){
		listaSent.setContieneSentenciaDevolver(true);
	}
	RESULT = listaSent;
:} | epsilon {:
	RESULT = new ListaSentenciasFuncion();
:};

/*================================================*
 *======================IF========================*
 *================================================*/

sentenciaif ::= COMIENZOSI:c expresion:ex  STARTIF DELIMFUNC listaSentencias rellenoif {:
	if(!ex.getTipo().getName().equals("BOOLEANO")){
		semanticErrorManager.semanticFatalError("La expresion que determina la condicion en la sentencia if de la linea "+ c.getLine() + " no se trata de una expresion logica.");
	}
:} FINBLOQUESENTENCIAS COMIENZOSI DSENTENCIAS ;

sentenciaifFuncion ::= COMIENZOSI:c expresion:ex  STARTIF DELIMFUNC listaSentenciasFuncion:listaSent rellenoifFuncion:listaRelleno {:
	if(!ex.getTipo().getName().equals("BOOLEANO")){
		semanticErrorManager.semanticFatalError("La expresion que determina la condicion en la sentencia if de la linea "+ c.getLine() + " no se trata de una expresion logica.");
	}
	
	Sentencia sent = new Sentencia();
	// Solo cuento que las sentencias if tienen una sentencia devolver si tanto en si como en sino se incluye la sentencia devolver
	if(listaRelleno.isEsRellenoIfFuncion() && listaSent.isContieneSentenciaDevolver() && listaRelleno.isContieneSentenciaDevolver()){
		sent.setContieneSentenciaDevolver(true);
	}
	sent.setIntermediateCode(new ArrayList());
	RESULT = sent;
:} FINBLOQUESENTENCIAS COMIENZOSI DSENTENCIAS ;

rellenoifFuncion ::=  ALTERNATIVASI DELIMFUNC  listaSentenciasFuncion:ls {:
	ls.setEsRellenoIfFuncion(true);
	RESULT = ls;
:} | epsilon {:
	RESULT = new ListaSentenciasFuncion();
:} ;

rellenoif ::=  ALTERNATIVASI DELIMFUNC  listaSentencias | epsilon ;

/*================================================*
 *======================FOR=======================*
 *================================================*/

sentenciafor ::= COMIENZOBUCLEPARA IDEN:id RANGOBUCLEPARA expresion:e1 RANGO expresion:e2 DELIMFUNC listaSentencias {:
	// Comprobamos que la variable indice esta declarada en las tablas de simbolos abiertos
	if(!scopeManager.containsSymbol(id.getLexema().toUpperCase())){
		semanticErrorManager.semanticFatalError("Variable del bucle para " + id.getLexema().toUpperCase() + " en linea " + id.getLine() + " no esta declarado anteriormente, error.");
	}

	// Comprobamos que el tipo de la variable indice es de tipo entero 
	if(!scopeManager.searchSymbol(id.getLexema().toUpperCase()).getType().equals(scopeManager.searchType("ENTERO"))){
		semanticErrorManager.semanticFatalError("El tipo de la variable del bucle para " + id.getLexema().toUpperCase() + " en linea " + id.getLine() + " no es de tipo entero, error.");
	}

	// Comprobamos que ambas expresiones del rango son del tipo entero
	if(!(e1.getTipo().equals(scopeManager.searchType("ENTERO")) && e2.getTipo().equals(scopeManager.searchType("ENTERO")))){
		semanticErrorManager.semanticFatalError("El tipo de alguna de las expresiones del rango del bucle para en linea " + id.getLine() + " no es de tipo entero, error.");
	}
:}FINBLOQUESENTENCIAS COMIENZOBUCLEPARA DSENTENCIAS;

sentenciaforFuncion ::= COMIENZOBUCLEPARA IDEN:id RANGOBUCLEPARA expresion:e1 RANGO expresion:e2 DELIMFUNC listaSentenciasFuncion {:
	// Comprobamos que la variable indice esta declarada en las tablas de simbolos abiertos
	if(!scopeManager.containsSymbol(id.getLexema().toUpperCase())){
		semanticErrorManager.semanticFatalError("Variable del bucle para " + id.getLexema().toUpperCase() + " en linea " + id.getLine() + " no esta declarado anteriormente, error.");
	}

	// Comprobamos que el tipo de la variable indice es de tipo entero 
	if(!scopeManager.searchSymbol(id.getLexema().toUpperCase()).getType().equals(scopeManager.searchType("ENTERO"))){
		semanticErrorManager.semanticFatalError("El tipo de la variable del bucle para " + id.getLexema().toUpperCase() + " en linea " + id.getLine() + " no es de tipo entero, error.");
	}

	// Comprobamos que ambas expresiones del rango son del tipo entero
	if(!(e1.getTipo().equals(scopeManager.searchType("ENTERO")) && e2.getTipo().equals(scopeManager.searchType("ENTERO")))){
		semanticErrorManager.semanticFatalError("El tipo de alguna de las expresiones del rango del bucle para en linea " + id.getLine() + " no es de tipo entero, error.");
	}

	// Aunque dentro del bloque de sentencias para contenga una sentencia devuelve, como cabe la posibilidad de que el bucle para no llegue a ejecutarse, debe existir una sentencia del bucle fuera del bloque de sentencias del bucle para. Por lo que dejamos new Sentencia() con la variable contieneDevuelve a false.
	Sentencia sent = new Sentencia();
	sent.setIntermediateCode(new ArrayList());
	RESULT = sent;
:}FINBLOQUESENTENCIAS COMIENZOBUCLEPARA DSENTENCIAS;

/*================================================*
 *===================ESCRIBIR=====================*
 *================================================*/

parametroEscribir ::= STRING:s {:
	ParametroEscribir p = new ParametroEscribir();
	p.setEsString(true);
	p.setCadena(s.getLexema().toUpperCase());
	RESULT = p;
:} | expresion:e1 {:
	if(!(e1.getTipo().equals(scopeManager.searchType("ENTERO")))){
		semanticErrorManager.semanticFatalError("El tipo del parametro pasado a una de las llamadas escribir() no es de tipo entero, error.");
	}
	ParametroEscribir p = new ParametroEscribir(); 
	p.setEsNumero(true);
	//Codigo intermedio: en expresion ya tenemos el codigo intermedio creado, tenemos que obtener su codigo intermedio, esatblecerlo al resultado y propagarlo
	p.setTemporal(e1.getTemporal());
	p.setIntermediateCode(e1.getIntermediateCode());
	RESULT = p;
:} | epsilon {:
	ParametroEscribir p = new ParametroEscribir();
	p.setEsVacio(true);
	RESULT = p;
:};

sentenciaEscribir ::= ESCRIBIR PIZQUIERDO parametroEscribir:p PDERECHO DSENTENCIAS {:
	Sentencia s = new Sentencia();
	ScopeIF scope = scopeManager.getCurrentScope();

	if(p.isEsString()){
		TemporalFactory tF = new TemporalFactory(scope);
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
		String textoEscrito = p.getCadena();
		LabelFactory lF = new LabelFactory();
		LabelIF lb = lF.create();
		TemporalIF temp = tF.create();
		cb.addQuadruple("ESCRIBCA", temp, lb);
		// Guardamos la cadena de caracteres en "listaCadenas" y recuperamos al final del programa principal
		listaCadenas.add(new Quadruple("CADENA", new Label(textoEscrito), lb));
		s.setIntermediateCode(cb.create());
		System.out.println("Codigo intermedio: " + s.getIntermediateCode());
		RESULT = s;
	}

	if(p.isEsNumero()){
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
		cb.addQuadruples(p.getIntermediateCode()); // busco el codigo de intermedio de lo de arriba
		cb.addQuadruple("ESCRIBENT", p.getTemporal());
		s.setIntermediateCode(cb.create());
		System.out.println("Codigo intermedio: " + s.getIntermediateCode());
		RESULT = s;
	}

	if(p.isEsVacio()){
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
		cb.addQuadruple("ESCRIBLN");
		s.setIntermediateCode(cb.create());
		System.out.println("Codigo intermedio: " + s.getIntermediateCode());
		RESULT = s;
	}
:};

/*================================================*
 *===================DEVOLVER=====================*
 *================================================*/

sentenciaDevolver ::= FRETURN:r expresion:expr DSENTENCIAS {:
	ScopeIF scope = scopeManager.getCurrentScope();
	String nombreFuncion = scope.getName(); // Obtenemos el nombre del scope actual
	TypeIF tipoFuncion = scopeManager.searchType(nombreFuncion); // Obtenemos el tipo de la funcion actual

	if(tipoFuncion instanceof TypeFunction){
		// Pasos para la comprobacion del tipo
		String tipoRetornoFuncion = ((TypeFunction)tipoFuncion).getTipoRetorno(); // Obtenemos el tipo de retorno de la funcion actual
		if(!expr.getTipo().getName().equals(tipoRetornoFuncion)){ // Lanzamos error si el tipo no coincide con la sentencia devolver
			semanticErrorManager.semanticFatalError("Error en el tipo del retorno de la linea " + r.getLine());
		}

		// Creacion de la sentencia devolver
		SentenciaDevolver sentenciaD = new SentenciaDevolver();
		RESULT = sentenciaD;

	}else{
		semanticErrorManager.semanticFatalError("Se ha detectado una sentencia devolver fuera de una funcion.");
	}	
:};



