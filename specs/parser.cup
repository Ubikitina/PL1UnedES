package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaración del código de usuario

action code {:
	
	// Codigo del equipo docente
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

	// Metodos creados por mi
	public void errorSiExisteSimbolo(String id){
		// Recuperamos el ambito y obtenemos la tabla de simbolos
		ScopeIF scope = scopeManager.getCurrentScope();
		SymbolTableIF tablaSimbolos = scope.getSymbolTable();

		// Comprobamos si la tabla de simbolos contiene el simbolo
		if(tablaSimbolos.containsSymbol(id)){
			semanticErrorManager.semanticFatalError("Constante " + id + " declarada anteriormente, error.");
		}
	}
:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaración de terminales

terminal Token RANGO;
terminal Token ASIGNACIONVECTOR;
terminal Token STARTIF;
terminal Token NOLOGICO;
terminal Token FRETURN;
terminal Token COMIENZOPROGRAMA;
terminal Token ENTERO;
terminal Token FINBLOQUESENTENCIAS;
terminal Token COMIENZOPROCEDIMIENTO;
terminal Token COMIENZOBUCLEPARA;
terminal Token BOOLEANO;
terminal Token COMIENZOSI;
terminal Token DECLVECTOR;
terminal Token CIZQUIERDO;
terminal Token DECLAREFUNCION;
terminal Token CDERECHO;
terminal Token IDEN;
terminal Token IGUALDAD;
terminal Token ALTERNATIVASI;
terminal Token DECLVARIABLES;
terminal Token STRING;
terminal Token FALSO;
terminal Token PARAMETROVALOR;
terminal Token PIZQUIERDO;
terminal Token PDERECHO;
terminal Token CIERTO;
terminal Token RANGOBUCLEPARA;
terminal Token PRODUCTO;
terminal Token SUMA;
terminal Token COMIENZOSUBPROGRAMAS;
terminal Token COMIENZODECLTIPOS;
terminal Token DIDENTIFICADORES;
terminal Token FINPROGRAMA;
terminal Token BCONSTANTES;
terminal Token ESCRIBIR;
terminal Token NUM;
terminal Token COMIENZO;
terminal Token YLOGICA;
terminal Token DELIMFUNC;
terminal Token DSENTENCIAS;
terminal Token MENORQUE;
terminal Token ASIGNACION;




// Declaración de no terminales


non terminal  			program;
non terminal Axiom		axiom;
non terminal  			epsilon;
non terminal defconstantes;
non terminal Valorconstante valorconstante;
non terminal seccionconstantes;
non terminal deftipos;
non terminal Tipovector tipovector;
non terminal Valorango valorango;
non terminal secciontipos;
non terminal Defvariables defvariables;
non terminal Tipovariable tipovariable;
non terminal Listavariables listavariables;
non terminal seccionvariables;
non terminal defsubprograma;
non terminal puntoycomaopcional;

non terminal tiporetornofuncion;
non terminal seccionsubprograma;
non terminal defprincipal;
non terminal Selectorvalororeferencia selectorvalororeferencia;


non terminal expresion;
non terminal expresionlvl2;
non terminal expresionlvl3;
non terminal expresionlvl4;
non terminal expresionlvl5;




non terminal miembrovector;
non terminal procedimiento;
non terminal funcion;
non terminal selectorpof;

non terminal parametrofuncionoproc;
non terminal llamadafuncion ; 

non terminal parteizquierdaasignacion;  
non terminal sentenciadeasignacion;

non terminal parametroEscribir ;
non terminal sentenciaEscribir ;

non terminal sentencia;
non terminal sentenciaFuncion;
non terminal listaSentencias;
non terminal listaSentenciasFuncion;
non terminal sentenciaif;
non terminal sentenciaifFuncion;
non terminal rellenoif;
non terminal rellenoifFuncion;
non terminal sentenciafor;
non terminal sentenciaforFuncion;
non terminal sentenciaDevolver;


non terminal parametroasignacion;

non terminal sentenciallamadafuncion;





// Declaración de relaciones de precedencia
precedence left		PIZQUIERDO, PDERECHO, YLOGICA, MENORQUE, IGUALDAD, CIZQUIERDO, CDERECHO, SUMA ;
precedence left PRODUCTO;
precedence right	NOLOGICO;

// Declaración de reglas de producción

start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {: 
  		// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		
  		//List intermediateCode = ax.getIntermediateCode ();
  		//finalCodeFactory.create (intermediateCode);

  		// En caso de no comentarse las dos sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest si el compilador no está completo. Esto es debido a que 
  		// aún no se tendrá implementada la generación de código intermedio ni final.
  		// Para la entrega final deberán descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};

axiom ::= defprincipal;

epsilon ::=;

/*================================================*
 *================CONSTANTES======================*
 *================================================*/

//Definición de constantes
defconstantes ::=   IDEN:id ASIGNACION valorconstante:valor DSENTENCIAS {:
	// Recuperamos el ambito y obtenemos la tabla de simbolos
	ScopeIF scope = scopeManager.getCurrentScope();
	SymbolTableIF tablaSimbolos = scope.getSymbolTable();

	// Comprobamos si la tabla de simbolos contiene el simbolo
	if(tablaSimbolos.containsSymbol(id.getLexema())){
		semanticErrorManager.semanticFatalError("Constante " + id.getLexema() + " en linea " + id.getLine() + " declarada anteriormente, error.");
	} else {
		semanticErrorManager.semanticDebug("Constante " + id.getLexema() + " en linea " + id.getLine() + " no declarada.");

		// Introducimos la constante en la tabla de simbolos
		if(valor.esNumero()){ // si es numero lo aniadimos como numero
			TypeIF t_entero = scopeManager.searchType("ENTERO");
			SymbolConstant simboloConstante = new SymbolConstant(scope, id.getLexema(), valor.getValor_num(), t_entero);
			tablaSimbolos.addSymbol(simboloConstante);
			semanticErrorManager.semanticDebug("Constante " + id.getLexema() + " con valor " + valor.getValor_num() + "  declarada.");
		}else{ // si no, es booleano, y lo aniadimos como booleano
			TypeIF t_booleano = scopeManager.searchType("BOOLEANO");
			SymbolConstant simboloConstante = new SymbolConstant(scope, id.getLexema(), valor.getValor_bool(), t_booleano);
			tablaSimbolos.addSymbol(simboloConstante);
			semanticErrorManager.semanticDebug("Constante " + id.getLexema() + " con valor " + valor.getValor_bool() + "  declarada.");
		}

	}


:} defconstantes | epsilon; 

valorconstante ::=   FALSO {:
	RESULT = new Valorconstante(false);
:} | CIERTO {:
	RESULT = new Valorconstante(true);
:} | NUM:valor_num {:
	RESULT = new Valorconstante(Integer.parseInt(valor_num.getLexema()));
:} ;

seccionconstantes ::= BCONSTANTES defconstantes | epsilon;


/*================================================*
 *==========DEFINICION DE TIPOS===================*
 *================================================*/

 //Definición de tipos
deftipos ::=IDEN:id ASIGNACION DECLVECTOR CIZQUIERDO valorango:rangoInferior RANGO valorango:rangoSuperior CDERECHO ASIGNACIONVECTOR tipovector:tipov  DSENTENCIAS {:
	// Recuperamos el ambito y obtenemos la tabla de tipos
	ScopeIF scope = scopeManager.getCurrentScope();
	TypeTableIF tablaTipos = scope.getTypeTable();

	// Comprobamos si la tabla de tipos contiene el tipo.
	if(tablaTipos.containsType(id.getLexema())){
		semanticErrorManager.semanticFatalError("Tipo " + id.getLexema() + " en linea " + id.getLine() + " incluido en la tabla de tipos anteriormente, error.");
	} else {
		if(rangoSuperior.getNum() > rangoInferior.getNum()){ // Solo crearemos el tipo si el rango superior es mayor que el inferior
			// Creamos el tipo
			TypeIF t_vector_nuevo = new TypeArray(scope, id.getLexema(), rangoInferior.getNum(), rangoSuperior.getNum(), tipov);
			tablaTipos.addType(t_vector_nuevo); // Introducimos el tipo en la tabla de tipos
			semanticErrorManager.semanticDebug("Tipo " + id.getLexema() + " con [" + ((TypeArray)t_vector_nuevo).imprimir() + "] aniadido a la tabla de tipos.");		
		} else {
			semanticErrorManager.semanticFatalError("El rango superior del vector " + id.getLexema() + " es mayor que el rango inferior.");
		}
	}
:} deftipos | epsilon;

tipovector ::=BOOLEANO {:
	RESULT = new Tipovector(scopeManager.searchType("BOOLEANO"), "BOOLEANO");
:} | ENTERO {:
	RESULT = new Tipovector(scopeManager.searchType("ENTERO"), "ENTERO");
:} ;

valorango ::= NUM:valor_num {:
	RESULT = new Valorango(Integer.parseInt(valor_num.getLexema()));
	//RESULT = Integer.parseInt(valor_num.getLexema());
:} | IDEN:id {:
	// Obtenemos el ambito
	ScopeIF scope = scopeManager.getCurrentScope();
	
	// Miramos si la tabla de simbolos contiene el simbolo, nos esperamos que lo haga . 
	if(scopeManager.containsSymbol(id.getLexema())){
		SymbolIF symbol = scopeManager.searchSymbol(id.getLexema());
		if(symbol instanceof SymbolConstant && symbol.getType().getName().equals("ENTERO")){
			RESULT = new Valorango(((SymbolConstant)symbol).getNum_value());
		}
	}else{
		semanticErrorManager.semanticFatalError("El simbolo "+id.getLexema()+" no esta contenido en la tabla de simbolos o no corresponde a una constante de tipo entero."); 
	}
	//RESULT = new Valorango(id.getLexema());
:} | miembrovector {:
	// PENDIENTE
:};

secciontipos ::= COMIENZODECLTIPOS deftipos | epsilon; 

/*================================================*
 *==========DEFINICION DE VARIABLES===============*
 *================================================*/

// Definición de variables
tipovariable ::= BOOLEANO {:
	RESULT = new Tipovariable(scopeManager.searchType("BOOLEANO"), "BOOLEANO");
:}| ENTERO {:
	RESULT = new Tipovariable(scopeManager.searchType("ENTERO"), "ENTERO");
:}| IDEN:id {:
	// Recuperamos el ambito
	ScopeIF scope = scopeManager.getCurrentScope();

	// Comprobamos si la tabla de tipos contiene el tipo.
	if(scopeManager.containsType(id.getLexema())){ //Si lo contiene, creamos el tipo
		RESULT = new Tipovariable(scopeManager.searchType(id.getLexema()), id.getLexema());
	} else { // Si no lo contiene, lanzamos error
		semanticErrorManager.semanticFatalError("Tipo " + id.getLexema() + " en linea " + id.getLine() + " no esta incluido en la tabla de tipos anteriormente, error.");
	}
:};

selectorvalororeferencia ::=  PARAMETROVALOR IDEN:id {:
	errorSiExisteSimbolo(id.getLexema());
	RESULT = new Selectorvalororeferencia(id.getLexema());
:} | expresion:ex {:
	RESULT = (Selectorvalororeferencia)ex; //ERROR no se porque no puedo quitar este casteo
	//PENDIENTE de terminar
:};

defvariables ::= listavariables:listVariables DELIMFUNC tipovariable:tipo puntoycomaopcional defvariables:hmTipoVariable {:
	if(hmTipoVariable == null){ // Si el hashmap de Tipo-ListaVariables esta vacio
		RESULT = new Defvariables(tipo.getTipo(), (ArrayList<Selectorvalororeferencia>)(listVariables.getListaV()));
	} else { // Si el hashmap de Tipo-ListaVariables contiene elementos
		hmTipoVariable.putParTipoVariable(tipo.getTipo(), (ArrayList<Selectorvalororeferencia>)(listVariables.getListaV()));
		RESULT = hmTipoVariable;
	}
:} | epsilon; 

listavariables ::= selectorvalororeferencia:selector DIDENTIFICADORES listavariables:listaV {:
	listaV.addElemento(selector);
	RESULT = listaV; 
:} | selectorvalororeferencia:selector {:
	RESULT = new Listavariables(selector);
:} | epsilon ;

seccionvariables ::= DECLVARIABLES defvariables:hmTipoVariables {: 
	// Obtenemos el ambito y la tabla de simbolos
	ScopeIF scope = scopeManager.getCurrentScope();
	SymbolTableIF symbolTable = scope.getSymbolTable();

	semanticErrorManager.semanticDebug("Variables creadas con su correspondiente tipo: "+hmTipoVariables.toString());

	HashMap<TypeIF, ArrayList<Selectorvalororeferencia>> mapa = hmTipoVariables.getVariablesDeUnTipo();

	Iterator<TypeIF> it = mapa.keySet().iterator();
		while(it.hasNext()){
			TypeIF next_tipo = it.next();
			ArrayList<Selectorvalororeferencia> lista_variables = mapa.get(next_tipo);
			for(int i = 0; i < lista_variables.size(); i++) { 
			    Selectorvalororeferencia variable = lista_variables.get(i);
				errorSiExisteSimbolo(variable.getId());
				SymbolVariable symbol = new SymbolVariable(scope, variable.getId(), next_tipo);
				symbolTable.addSymbol(symbol);
			} 
		}


:}| epsilon  ;

puntoycomaopcional ::= DSENTENCIAS | epsilon;


/*================================================*
 *================SUBPROGRAMAS====================*
 *================================================*/

//reglas de subprogramas
tiporetornofuncion ::= IDEN | tipovector ;

procedimiento ::= COMIENZOPROCEDIMIENTO IDEN:id {:
	// Creamos el ambito con el nombre del procedimiento
	String idLexema = id.getLexema();
	scopeManager.openScope(idLexema);
	ScopeIF scope = scopeManager.getCurrentScope();

	// Comprobaciones para ver si el ambito se ha creado correctamente
	semanticErrorManager.semanticDebug("El nombre del nuevo ambito es: " + scope.getName());
	semanticErrorManager.semanticDebug("El nivel del nuevo ambito es: " + scope.getLevel());
	
	// Obtencion de la tabla de tipos y simbolos //BORRAR creo, no se usa para nada
	SymbolTableIF symbolTable = scope.getSymbolTable();
	TypeTableIF typeTable = scope.getTypeTable();
	
:} PIZQUIERDO defvariables PDERECHO DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO sentencia listaSentencias   FINBLOQUESENTENCIAS DSENTENCIAS {:
	// Cerramos el ambito actual (current scope)
	scopeManager.closeScope();
	semanticErrorManager.semanticDebug("Se ha cerrado el ambito actual.");
:};

funcion ::= DECLAREFUNCION IDEN:id {:
	// Creamos el ambito con el nombre de la funcion
	String idLexema = id.getLexema();
	scopeManager.openScope(idLexema);
	ScopeIF scope = scopeManager.getCurrentScope();
	
	// Comprobaciones para ver si el ambito se ha creado correctamente
	semanticErrorManager.semanticDebug("El nombre del nuevo ambito es: " + scope.getName());
	semanticErrorManager.semanticDebug("El nivel del nuevo ambito es: " + scope.getLevel());
	
	// Obtencion de la tabla de tipos y simbolos //BORRAR creo, no se usa para nada
	SymbolTableIF symbolTable = scope.getSymbolTable();
	TypeTableIF typeTable = scope.getTypeTable();
	
:} PIZQUIERDO defvariables PDERECHO DELIMFUNC tiporetornofuncion DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO sentenciaFuncion listaSentenciasFuncion FINBLOQUESENTENCIAS DSENTENCIAS {:
	// Cerramos el ambito actual (current scope)
	scopeManager.closeScope();
	semanticErrorManager.semanticDebug("Se ha cerrado el ambito actual.");
:} ;
selectorpof ::= procedimiento | funcion ;
defsubprograma ::=selectorpof  defsubprograma | epsilon ;
seccionsubprograma ::=COMIENZOSUBPROGRAMAS  defsubprograma  | epsilon ;

/*================================================*
 *==============PROGRAMA PRINCIPAL================*
 *================================================*/

// Definición de programa principal
defprincipal ::= COMIENZOPROGRAMA IDEN:id {:

	// Creamos el ambito global con el nombre del programa principal
	String idLexema = id.getLexema();
	scopeManager.openScope(idLexema);
	ScopeIF scope = scopeManager.getCurrentScope();
	// Comprobaciones para ver si el ambito se ha creado correctamente
	semanticErrorManager.semanticDebug("El nombre del nuevo ambito es: " + scope.getName());
	semanticErrorManager.semanticDebug("El nivel del nuevo ambito es: " + scope.getLevel()); // El nivel esperado es 0
	
	// Obtencion de la tabla de tipos y simbolos
	SymbolTableIF symbolTable = scope.getSymbolTable(); //BORRAR No estoy segura para que lo recupero si no se usa
	TypeTableIF typeTable = scope.getTypeTable();
	
	// Introducimos los tipos entero y booleano que describe el enunciado
	TypeSimple tsEntero = new TypeSimple(scope, "ENTERO");
	typeTable.addType("ENTERO",tsEntero);
	TypeSimple tsBooleano = new TypeSimple(scope, "BOOLEANO");
	typeTable.addType("BOOLEANO",tsBooleano);
	
:} DELIMFUNC seccionconstantes secciontipos seccionvariables seccionsubprograma COMIENZO listaSentencias FINBLOQUESENTENCIAS FINPROGRAMA {:
	// Cerramos el ambito actual (current scope)
	scopeManager.closeScope();
	semanticErrorManager.semanticDebug("Se ha cerrado el ambito actual.");
:};

/*================================================*
 *==================EXPRESIONES===================*
 *================================================*/

// Expresiones
expresion ::=  expresion MENORQUE  expresion |  expresion IGUALDAD  expresion | IDEN:id {:
	RESULT = new Selectorvalororeferencia(id.getLexema());
:} | llamadafuncion | CIERTO | FALSO | miembrovector | NUM | expresionlvl2;
expresionlvl2 ::=  expresion SUMA expresion | expresionlvl3 ;
expresionlvl3 ::=  expresion YLOGICA expresion |  expresion PRODUCTO expresion | expresionlvl4;
expresionlvl4 ::= NOLOGICO  expresion | expresionlvl5 ;
expresionlvl5 ::= PIZQUIERDO expresion PDERECHO | CIZQUIERDO expresion CDERECHO  ;

/*================================================*
 *================ACCESO A VECTORES===============*
 *================================================*/

// Acceso a vectores
miembrovector::= IDEN CIZQUIERDO valorango CDERECHO;

/*================================================*
 *============SENTENCIAS DE ASIGNACION============*
 *================================================*/
 
// Sentencias de asignacion
parteizquierdaasignacion ::= IDEN |miembrovector  ;
sentenciadeasignacion ::= parteizquierdaasignacion ASIGNACION parametroasignacion DSENTENCIAS; 
parametroasignacion ::= expresion ;

/*================================================*
 *===============LLAMADA A FUNCION================*
 *================================================*/

// Llamada a función
parametrofuncionoproc ::=     listavariables ;
llamadafuncion ::= IDEN PIZQUIERDO parametrofuncionoproc PDERECHO;  
sentenciallamadafuncion ::= llamadafuncion DSENTENCIAS;

/*================================================*
 *===================SENTENCIAS===================*
 *================================================*/

// Sentencias
sentencia ::= sentenciadeasignacion | sentenciaif | sentenciafor | sentenciaEscribir | sentenciallamadafuncion ;
sentenciaFuncion ::= sentenciadeasignacion | sentenciaifFuncion | sentenciaforFuncion | sentenciaEscribir | sentenciallamadafuncion | sentenciaDevolver;
listaSentencias ::= sentencia  listaSentencias | epsilon;
listaSentenciasFuncion ::= sentenciaFuncion listaSentenciasFuncion | epsilon;

/*================================================*
 *======================IF========================*
 *================================================*/

// if
sentenciaif ::= COMIENZOSI expresion  STARTIF DELIMFUNC listaSentencias rellenoif  FINBLOQUESENTENCIAS COMIENZOSI DSENTENCIAS ;
sentenciaifFuncion ::= COMIENZOSI expresion  STARTIF DELIMFUNC listaSentenciasFuncion rellenoifFuncion  FINBLOQUESENTENCIAS COMIENZOSI DSENTENCIAS ;
rellenoifFuncion ::=  ALTERNATIVASI DELIMFUNC  listaSentenciasFuncion | epsilon ;
rellenoif ::=  ALTERNATIVASI DELIMFUNC  listaSentencias | epsilon ;

/*================================================*
 *======================FOR=======================*
 *================================================*/

// for 
sentenciafor ::= COMIENZOBUCLEPARA IDEN RANGOBUCLEPARA expresion RANGO expresion DELIMFUNC listaSentencias FINBLOQUESENTENCIAS COMIENZOBUCLEPARA DSENTENCIAS;
sentenciaforFuncion ::= COMIENZOBUCLEPARA IDEN RANGOBUCLEPARA expresion RANGO expresion DELIMFUNC listaSentenciasFuncion FINBLOQUESENTENCIAS COMIENZOBUCLEPARA DSENTENCIAS;

/*================================================*
 *===================ESCRIBIR=====================*
 *================================================*/

// escribir. 
parametroEscribir ::= STRING | expresion | epsilon ;
sentenciaEscribir ::= ESCRIBIR PIZQUIERDO parametroEscribir PDERECHO DSENTENCIAS;

/*================================================*
 *===================DEVOLVER=====================*
 *================================================*/

// devolver
sentenciaDevolver ::= FRETURN expresion DSENTENCIAS;



