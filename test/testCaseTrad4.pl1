#
# *************************************************************
# * PUTEADOR - COMPROBADOR DE NIVEL 2 (NIVEL MEDIO) PARA PL2  *
# *                   BY NOMED - GRUPO B                      *
# *************************************************************
# * COMO USAR ESTE PUTEADOR!!!!!!!!!!!!!!!!!!!!!!!!!!!!!      *
# * 1)SI LO EJECUTAS CONFORME ESTA,TU COMPILADOR NO DEBERIA   *
# *   GENERARTE NINGUN ERROR						     	     *
# * 2)PERO SI DESCOMENTAS UNO A UNO LOS COMENTARIOS EN ESE    *
# * PUNTO DEBE DE DETECTAR EL ERROR DESCRITO A LA DERECHA     *
# *************************************************************                                  
# * USALO, MEJORALO Y COMPARTELO                              *
# * 				PERO SOBRE TODO APRUEBA ESTA MEGDA           *
# *************************************************************
# * SI TE SIRVIO PARA MEJORAR TU PED DIMELO Y TE PASO         *
# *			EL TEST DE NIVEL 3 (NIVEL JODIDO)                *
# *************************************************************
# * 	         			RESPETO Y HACKING                    *
# *************************************************************
#*)

#NIVEL 1 COMPROBRACION DE :
#CONST - VAR - TYPE - EXPRESIONES LOGICAS - EXPRESIONES ARITMETICAS
#- SENTENCIAS Y RETURN EN EL PROGRAMA PRINCIPAL Y EN BLOQUES IF Y FOR - BLOQUES IF-THEN-ELSE
#CON Y SIN RETURN - BUCLES FOR 


programa dos:
	constantes
	
		const1 = 10;
  		const2 = 20;
  		const3 = falso;
  		const4 = cierto;
 	tipos	
  		
   		tipo1 = vector[1..const1] de entero;
  		tipo2 = vector[1..20] de booleano;
  		
  variables
  		var1:booleano;
  		var2:entero;
  		var3:tipo1;
  		var4:tipo2;
  		var10,var11,var12:booleano;
  		var20,var21,var22:entero;
  subprogramas
	  funcion funcion1(a,b:entero;c:booleano):entero:
		comienzo
		  	devolver 1;
	  	fin;
	  
	  procedimiento funcion2(a,b,c:entero):
		  comienzo
		  	a = 1; ##hace falta 1 sentencia minimo
		  fin;
	  
	  
	  #funcion funcion3():entero:
	  #comienzo
	  #	var1 = cierto;					#falta return
	  #fin;	
	  											
	 											
	  
	procedimiento funcion3():
		  comienzo
	  		var1 = cierto; ##hace falta 1 sentencia minimo
	  fin;	
	  
	procedimiento funcion4():
		comienzo
	  		escribir();
		fin;
  
  comienzo
  	funcion3();
  	funcion4();

  	#funcion2();								#error faltan los parametros
  	funcion2(1,2,3);
  	#var2 = funcion2(1,2,3);					#error funcion2 no es una funcion
  	var2 =funcion1(1,2,falso);

	#var10 = (1 == 1) y 1;					#error la segunda expresion no es booleana

	#var10();									#var10 no es un procedure
	
	var10 =(1<1) y falso;
	var20 = 10 + 1 + 1;
	
	var20=funcion1(2+2,3+4,(1<1));
	#var20=funcion1(2+2,1<1,(1<1));			#error param 2 debe ser entero
	var20=funcion1(2+2,var3[2],(1<1));	

	para var20 en 1 .. 10 :
		var3[const1]=var20;
		escribir(var20);
	fin para;
	
	para var20 en 1 .. 20 :
		var4[const1]= no ( ((5+3)+4) < (6+1) );
	fin para;

	
	#para var20 en 1 .. 20 :
	#	var4[const1]= no ((5+3)+4 < falso);	#error el FALSE deberia ser entero
	#fin para;
	

  fin.
